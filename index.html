<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Structure Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 20px;
            color: #fff;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: inline-block;
            width: 180px;
            font-weight: 500;
        }

        input[type="number"],
        input[type="file"],
        select {
            padding: 8px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 14px;
        }

        input[type="number"] {
            width: 120px;
        }

        input[type="file"] {
            width: 300px;
        }

        select {
            width: 120px;
            cursor: pointer;
        }

        button {
            padding: 10px 24px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #3a7bc8;
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #4a8bd8;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .value-display {
            margin-left: 10px;
            color: #888;
            font-size: 13px;
        }

        .canvas-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        canvas {
            border: 1px solid #444;
            max-width: 100%;
            height: auto;
            image-rendering: pixelated;
        }

        .progress-container {
            margin-top: 15px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #444;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #440154, #21918c, #fde724);
            width: 0%;
            transition: width 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        .info {
            margin-top: 10px;
            color: #888;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Structure Visualizer</h1>

        <div class="controls">
            <div class="control-group">
                <label for="audioFile">Audio File:</label>
                <input type="file" id="audioFile" accept="audio/*">
            </div>

            <div class="control-group">
                <label for="bpm">BPM:</label>
                <input type="number" id="bpm" value="120" min="1" max="300" step="0.1">
            </div>

            <div class="control-group">
                <label for="samplesPerBeat">Samples per Beat:</label>
                <select id="samplesPerBeat">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="4">4</option>
                    <option value="8">8</option>
                    <option value="16">16</option>
                    <option value="32">32</option>
                    <option value="64" selected>64</option>
                    <option value="128">128</option>
                    <option value="256">256</option>
                    <option value="512">512</option>
                </select>
            </div>

            <div class="control-group">
                <label for="windowSize">Window Size (samples):</label>
                <input type="number" id="windowSize" value="2048" min="128" max="8192" step="128">
            </div>

            <div class="control-group">
                <label for="zOrderOffset">Z-Order Offset (beats):</label>
                <input type="number" id="zOrderOffset" value="0" step="0.1">
            </div>

            <div class="control-group">
                <label for="vizMode">Visualization Mode:</label>
                <select id="vizMode">
                    <option value="mono">Mono (Power - Viridis)</option>
                    <option value="rgb">RGB (Frequency Bands)</option>
                </select>
            </div>

            <div class="control-group" id="filterControlsGroup" style="display: none;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold;">Frequency Band Cutoffs:</label>
                <div style="margin-left: 180px;">
                    <div style="margin-bottom: 8px;">
                        <label style="width: 120px;">Low/Mid (Hz):</label>
                        <input type="number" id="lowMidCutoff" value="250" min="50" max="1000" step="10">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="width: 120px;">Mid/High (Hz):</label>
                        <input type="number" id="midHighCutoff" value="4000" min="1000" max="12000" step="100">
                    </div>
                    <div style="font-size: 12px; color: #888; margin-top: 5px;">
                        Red: Low (20 - <span id="lowMidDisplay">250</span> Hz)<br>
                        Green: Mid (<span id="lowMidDisplay2">250</span> - <span id="midHighDisplay">4000</span> Hz)<br>
                        Blue: High (<span id="midHighDisplay2">4000</span> - 20000 Hz)
                    </div>
                </div>
            </div>

            <div class="control-group">
                <button id="processButton" disabled>Process</button>
            </div>

            <div class="control-group info" id="calculatedInfo">
                Window interval: -- ms | Canvas size: --
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="visualizer"></canvas>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Viridis colormap (256 colors)
        const viridisMap = [
            [68, 1, 84], [68, 2, 86], [69, 4, 87], [69, 5, 89], [70, 7, 90], [70, 8, 92], [70, 10, 93], [70, 11, 94],
            [71, 13, 96], [71, 14, 97], [71, 16, 99], [71, 17, 100], [71, 19, 101], [72, 20, 103], [72, 22, 104], [72, 23, 105],
            [72, 24, 106], [72, 26, 108], [72, 27, 109], [72, 28, 110], [72, 29, 111], [72, 31, 112], [72, 32, 113], [72, 33, 115],
            [72, 35, 116], [72, 36, 117], [72, 37, 118], [72, 38, 119], [72, 40, 120], [72, 41, 121], [71, 42, 122], [71, 44, 122],
            [71, 45, 123], [71, 46, 124], [71, 47, 125], [70, 48, 126], [70, 50, 126], [70, 51, 127], [70, 52, 128], [69, 53, 129],
            [69, 55, 129], [69, 56, 130], [68, 57, 131], [68, 58, 131], [68, 59, 132], [67, 61, 132], [67, 62, 133], [66, 63, 133],
            [66, 64, 134], [66, 65, 134], [65, 66, 135], [65, 68, 135], [64, 69, 136], [64, 70, 136], [63, 71, 136], [63, 72, 137],
            [62, 73, 137], [62, 74, 137], [62, 76, 138], [61, 77, 138], [61, 78, 138], [60, 79, 138], [60, 80, 139], [59, 81, 139],
            [59, 82, 139], [58, 83, 139], [58, 84, 140], [57, 85, 140], [57, 86, 140], [56, 88, 140], [56, 89, 140], [55, 90, 140],
            [55, 91, 141], [54, 92, 141], [54, 93, 141], [53, 94, 141], [53, 95, 141], [52, 96, 141], [52, 97, 141], [51, 98, 141],
            [51, 99, 141], [50, 100, 142], [50, 101, 142], [49, 102, 142], [49, 103, 142], [49, 104, 142], [48, 105, 142], [48, 106, 142],
            [47, 107, 142], [47, 108, 142], [46, 109, 142], [46, 110, 142], [46, 111, 142], [45, 112, 142], [45, 113, 142], [44, 113, 142],
            [44, 114, 142], [44, 115, 142], [43, 116, 142], [43, 117, 142], [42, 118, 142], [42, 119, 142], [42, 120, 142], [41, 121, 142],
            [41, 122, 142], [41, 123, 142], [40, 124, 142], [40, 125, 142], [39, 126, 142], [39, 127, 142], [39, 128, 142], [38, 129, 142],
            [38, 130, 142], [38, 130, 142], [37, 131, 142], [37, 132, 142], [37, 133, 142], [36, 134, 142], [36, 135, 142], [35, 136, 142],
            [35, 137, 142], [35, 138, 141], [34, 139, 141], [34, 140, 141], [34, 141, 141], [33, 142, 141], [33, 143, 141], [33, 144, 141],
            [33, 145, 140], [32, 146, 140], [32, 146, 140], [32, 147, 140], [31, 148, 140], [31, 149, 139], [31, 150, 139], [31, 151, 139],
            [31, 152, 139], [31, 153, 138], [31, 154, 138], [30, 155, 138], [30, 156, 137], [30, 157, 137], [31, 158, 137], [31, 159, 136],
            [31, 160, 136], [31, 161, 136], [31, 161, 135], [31, 162, 135], [32, 163, 134], [32, 164, 134], [33, 165, 133], [33, 166, 133],
            [34, 167, 133], [34, 168, 132], [35, 169, 131], [36, 170, 131], [37, 171, 130], [37, 172, 130], [38, 173, 129], [39, 173, 129],
            [40, 174, 128], [41, 175, 127], [42, 176, 127], [44, 177, 126], [45, 178, 125], [46, 179, 124], [47, 180, 124], [49, 181, 123],
            [50, 182, 122], [52, 182, 121], [53, 183, 121], [55, 184, 120], [56, 185, 119], [58, 186, 118], [59, 187, 117], [61, 188, 116],
            [63, 188, 115], [64, 189, 114], [66, 190, 113], [68, 191, 112], [70, 192, 111], [72, 193, 110], [74, 193, 109], [76, 194, 108],
            [78, 195, 107], [80, 196, 106], [82, 197, 105], [84, 197, 104], [86, 198, 103], [88, 199, 101], [90, 200, 100], [92, 200, 99],
            [94, 201, 98], [96, 202, 96], [99, 203, 95], [101, 203, 94], [103, 204, 92], [105, 205, 91], [108, 205, 90], [110, 206, 88],
            [112, 207, 87], [115, 208, 86], [117, 208, 84], [119, 209, 83], [122, 209, 81], [124, 210, 80], [127, 211, 78], [129, 211, 77],
            [132, 212, 75], [134, 213, 73], [137, 213, 72], [139, 214, 70], [142, 214, 69], [144, 215, 67], [147, 215, 65], [149, 216, 64],
            [152, 216, 62], [155, 217, 60], [157, 217, 59], [160, 218, 57], [162, 218, 55], [165, 219, 54], [168, 219, 52], [170, 220, 50],
            [173, 220, 48], [176, 221, 47], [178, 221, 45], [181, 222, 43], [184, 222, 41], [186, 222, 40], [189, 223, 38], [192, 223, 37],
            [194, 223, 35], [197, 224, 33], [200, 224, 32], [202, 225, 31], [205, 225, 29], [208, 225, 28], [210, 226, 27], [213, 226, 26],
            [216, 226, 25], [218, 227, 25], [221, 227, 24], [223, 227, 24], [226, 228, 24], [229, 228, 25], [231, 228, 25], [234, 229, 26],
            [236, 229, 27], [239, 229, 28], [241, 229, 29], [244, 230, 30], [246, 230, 32], [248, 230, 33], [251, 231, 35], [253, 231, 37]
        ];

        // Z-order curve functions
        function interleave(x, y) {
            let z = 0;
            for (let i = 0; i < 16; i++) {
                z |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
            }
            return z;
        }

        function getZOrderCoordinates(index, width) {
            // Calculate x and y from linear index using Z-order curve
            let x = 0, y = 0;
            for (let i = 0; i < 16; i++) {
                x |= (index & (1 << (2 * i))) >> i;
                y |= (index & (1 << (2 * i + 1))) >> (i + 1);
            }
            return { x, y };
        }

        // Calculate RMS power of a window
        function calculateRMSPower(audioData, startSample, windowSize) {
            let sum = 0;
            const endSample = Math.min(startSample + windowSize, audioData.length);
            const actualWindowSize = endSample - startSample;

            for (let i = startSample; i < endSample; i++) {
                sum += audioData[i] * audioData[i];
            }

            return Math.sqrt(sum / actualWindowSize);
        }

        // Convert power to color using viridis colormap
        function powerToColor(power, minPower, maxPower) {
            // Handle edge case where all powers are the same
            if (minPower === maxPower) {
                const [r, g, b] = viridisMap[128]; // Use middle color
                return [r, g, b, 255];
            }

            const normalized = (power - minPower) / (maxPower - minPower);
            const index = Math.floor(Math.max(0, Math.min(1, normalized)) * 255);
            const [r, g, b] = viridisMap[index];
            return [r, g, b, 255];
        }

        // Main application state
        let audioContext;
        let audioBuffer;
        let isProcessing = false;

        // Cached computation results for quick redraw
        let cachedPowers = null; // For mono mode: single power array
        let cachedRGBPowers = null; // For RGB mode: {low, mid, high} arrays
        let cachedCanvasSize = 0;
        let cachedSamplesPerBeat = 0;
        let cachedVizMode = 'mono';

        // Max power levels for normalization
        let maxPowerMono = 1.0; // Max power in mono mode
        let maxPowerRGB = { low: 1.0, mid: 1.0, high: 1.0 }; // Max power per band in RGB mode

        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const calculatedInfo = document.getElementById('calculatedInfo');

        // Input elements
        const audioFileInput = document.getElementById('audioFile');
        const bpmInput = document.getElementById('bpm');
        const samplesPerBeatInput = document.getElementById('samplesPerBeat');
        const windowSizeInput = document.getElementById('windowSize');
        const zOrderOffsetInput = document.getElementById('zOrderOffset');
        const vizModeInput = document.getElementById('vizMode');
        const filterControlsGroup = document.getElementById('filterControlsGroup');
        const lowMidCutoffInput = document.getElementById('lowMidCutoff');
        const midHighCutoffInput = document.getElementById('midHighCutoff');
        const processButton = document.getElementById('processButton');

        // Initialize audio context on user interaction
        audioFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                processButton.disabled = false;
            } catch (error) {
                console.error('Error loading audio:', error);
                alert('Error loading audio file. Please try another file.');
            }
        });

        // Process button click handler
        processButton.addEventListener('click', () => {
            if (audioBuffer && !isProcessing) {
                processAudio();
            }
        });

        // Z-order offset change handler - instant redraw without recomputing
        zOrderOffsetInput.addEventListener('input', () => {
            if ((cachedPowers || cachedRGBPowers) && !isProcessing) {
                redrawCanvas();
            }
        });

        // Visualization mode change handler
        vizModeInput.addEventListener('change', () => {
            const isRGB = vizModeInput.value === 'rgb';
            filterControlsGroup.style.display = isRGB ? 'block' : 'none';
        });

        // Update filter cutoff displays
        function updateFilterDisplays() {
            const lowMid = lowMidCutoffInput.value;
            const midHigh = midHighCutoffInput.value;
            document.getElementById('lowMidDisplay').textContent = lowMid;
            document.getElementById('lowMidDisplay2').textContent = lowMid;
            document.getElementById('midHighDisplay').textContent = midHigh;
            document.getElementById('midHighDisplay2').textContent = midHigh;
        }

        lowMidCutoffInput.addEventListener('input', updateFilterDisplays);
        midHighCutoffInput.addEventListener('input', updateFilterDisplays);

        // Redraw canvas with current Z-order offset using cached data
        function redrawCanvas() {
            if (!cachedPowers && !cachedRGBPowers) return;

            const zOrderOffsetBeats = parseFloat(zOrderOffsetInput.value);
            const zOrderOffset = Math.round(zOrderOffsetBeats * cachedSamplesPerBeat);

            // Create new image data
            const imageData = ctx.createImageData(cachedCanvasSize, cachedCanvasSize);

            // Clear to black
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i + 3] = 255; // Set alpha to opaque
            }

            if (cachedVizMode === 'mono') {
                // Mono mode: Use Viridis colormap with normalized scale
                const minPower = 0;
                const maxPower = maxPowerMono;

                for (let i = 0; i < cachedPowers.length; i++) {
                    const index = i + zOrderOffset;
                    const { x, y } = getZOrderCoordinates(index, cachedCanvasSize);

                    if (x < cachedCanvasSize && y < cachedCanvasSize) {
                        const color = powerToColor(cachedPowers[i], minPower, maxPower);
                        const pixelIndex = (y * cachedCanvasSize + x) * 4;
                        imageData.data[pixelIndex] = color[0];
                        imageData.data[pixelIndex + 1] = color[1];
                        imageData.data[pixelIndex + 2] = color[2];
                        imageData.data[pixelIndex + 3] = color[3];
                    }
                }
            } else {
                // RGB mode: Map frequency bands to RGB channels with normalization
                for (let i = 0; i < cachedRGBPowers.low.length; i++) {
                    const index = i + zOrderOffset;
                    const { x, y } = getZOrderCoordinates(index, cachedCanvasSize);

                    if (x < cachedCanvasSize && y < cachedCanvasSize) {
                        const pixelIndex = (y * cachedCanvasSize + x) * 4;
                        // Normalize each band by its max power, then scale to 0-255
                        const normalizedLow = Math.min(1, cachedRGBPowers.low[i] / maxPowerRGB.low);
                        const normalizedMid = Math.min(1, cachedRGBPowers.mid[i] / maxPowerRGB.mid);
                        const normalizedHigh = Math.min(1, cachedRGBPowers.high[i] / maxPowerRGB.high);

                        imageData.data[pixelIndex] = Math.floor(normalizedLow * 255);
                        imageData.data[pixelIndex + 1] = Math.floor(normalizedMid * 255);
                        imageData.data[pixelIndex + 2] = Math.floor(normalizedHigh * 255);
                        imageData.data[pixelIndex + 3] = 255;
                    }
                }
            }

            // Render to canvas
            ctx.putImageData(imageData, 0, 0);
        }

        // Apply frequency filtering to separate audio into 3 bands
        async function applyFrequencyFiltering(audioBuffer, lowMidCutoff, midHighCutoff) {
            const sampleRate = audioBuffer.sampleRate;
            const length = audioBuffer.length;

            // Create offline context with 3 channels (one for each band)
            const offlineCtx = new OfflineAudioContext(3, length, sampleRate);

            // Create source
            const source = offlineCtx.createBufferSource();
            source.buffer = audioBuffer;

            // Create filters for each frequency band
            // Low band: Lowpass filter
            const lowFilter = offlineCtx.createBiquadFilter();
            lowFilter.type = 'lowpass';
            lowFilter.frequency.value = lowMidCutoff;
            lowFilter.Q.value = 0.7071; // Butterworth response

            // Mid band: Bandpass filter
            const midFilter = offlineCtx.createBiquadFilter();
            midFilter.type = 'bandpass';
            midFilter.frequency.value = Math.sqrt(lowMidCutoff * midHighCutoff); // Geometric mean
            midFilter.Q.value = Math.sqrt(lowMidCutoff * midHighCutoff) / (midHighCutoff - lowMidCutoff);

            // High band: Highpass filter
            const highFilter = offlineCtx.createBiquadFilter();
            highFilter.type = 'highpass';
            highFilter.frequency.value = midHighCutoff;
            highFilter.Q.value = 0.7071; // Butterworth response

            // Create channel merger
            const merger = offlineCtx.createChannelMerger(3);

            // Connect: source -> filters -> merger -> destination
            source.connect(lowFilter);
            source.connect(midFilter);
            source.connect(highFilter);
            lowFilter.connect(merger, 0, 0);
            midFilter.connect(merger, 0, 1);
            highFilter.connect(merger, 0, 2);
            merger.connect(offlineCtx.destination);

            // Start and render
            source.start(0);
            const filteredBuffer = await offlineCtx.startRendering();

            // Return the 3 filtered channels
            return {
                low: filteredBuffer.getChannelData(0),
                mid: filteredBuffer.getChannelData(1),
                high: filteredBuffer.getChannelData(2)
            };
        }

        async function processAudio() {
            if (isProcessing || !audioBuffer) return;

            isProcessing = true;
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';

            const bpm = parseFloat(bpmInput.value);
            const samplesPerBeat = parseInt(samplesPerBeatInput.value);
            const windowSize = parseInt(windowSizeInput.value);
            const zOrderOffsetBeats = parseFloat(zOrderOffsetInput.value);
            const zOrderOffset = Math.round(zOrderOffsetBeats * samplesPerBeat);
            const vizMode = vizModeInput.value;

            const sampleRate = audioBuffer.sampleRate;
            const duration = audioBuffer.duration;

            // Apply frequency filtering if in RGB mode
            let audioData, filteredBands;
            if (vizMode === 'rgb') {
                const lowMidCutoff = parseFloat(lowMidCutoffInput.value);
                const midHighCutoff = parseFloat(midHighCutoffInput.value);

                progressFill.textContent = 'Filtering...';
                filteredBands = await applyFrequencyFiltering(audioBuffer, lowMidCutoff, midHighCutoff);
                progressFill.textContent = '0%';
            } else {
                // Get mono audio data for power mode
                audioData = audioBuffer.getChannelData(0);
            }

            // Calculate window interval
            const beatsPerSecond = bpm / 60;
            const windowsPerSecond = beatsPerSecond * samplesPerBeat;
            const windowIntervalSeconds = 1 / windowsPerSecond;
            const windowIntervalSamples = windowIntervalSeconds * sampleRate;

            // Calculate number of windows
            const audioLength = vizMode === 'rgb' ? filteredBands.low.length : audioData.length;
            const totalWindows = Math.floor(audioLength / windowIntervalSamples);

            // Calculate canvas dimensions (smallest square power of 2 that fits all windows)
            const dimension = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(totalWindows))));
            const canvasSize = dimension;

            // Update info
            calculatedInfo.textContent = `Window interval: ${(windowIntervalSeconds * 1000).toFixed(4)} ms | Canvas size: ${canvasSize}x${canvasSize} | Total windows: ${totalWindows}`;

            // Setup canvas
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            canvas.style.width = `${Math.min(800, canvasSize)}px`;
            canvas.style.height = `${Math.min(800, canvasSize)}px`;

            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            const imageData = ctx.createImageData(canvasSize, canvasSize);

            if (vizMode === 'mono') {
                // Mono mode: Compute single power and use Viridis colormap
                const powers = [];

                // Use previous max power during processing for real-time rendering
                const minPower = 0;
                const tempMaxPower = maxPowerMono;

                for (let i = 0; i < totalWindows; i++) {
                    const startSample = Math.round(i * windowIntervalSamples);
                    const power = calculateRMSPower(audioData, startSample, windowSize);
                    powers.push(power);

                    // Plot using Z-order curve with Viridis colormap (using temp max)
                    const index = i + zOrderOffset;
                    const { x, y } = getZOrderCoordinates(index, canvasSize);

                    if (x < canvasSize && y < canvasSize) {
                        const color = powerToColor(power, minPower, tempMaxPower);
                        const pixelIndex = (y * canvasSize + x) * 4;
                        imageData.data[pixelIndex] = color[0];
                        imageData.data[pixelIndex + 1] = color[1];
                        imageData.data[pixelIndex + 2] = color[2];
                        imageData.data[pixelIndex + 3] = color[3];
                    }

                    // Update canvas and progress every 100 samples
                    if (i % 100 === 0) {
                        ctx.putImageData(imageData, 0, 0);
                        const progress = (i / totalWindows) * 100;
                        progressFill.style.width = `${progress}%`;
                        progressFill.textContent = `${Math.round(progress)}%`;
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // Calculate actual max power from computed values
                maxPowerMono = Math.max(...powers);
                if (maxPowerMono === 0) maxPowerMono = 1.0; // Avoid division by zero

                // Cache for instant redraw (must be set before redrawCanvas)
                cachedPowers = powers;
                cachedRGBPowers = null;
                cachedCanvasSize = canvasSize;
                cachedSamplesPerBeat = samplesPerBeat;
                cachedVizMode = vizMode;

                // Redraw with correct normalization
                redrawCanvas();
            } else {
                // RGB mode: Compute 3 powers and map to RGB channels
                const lowPowers = [];
                const midPowers = [];
                const highPowers = [];

                // Use previous max powers during processing for real-time rendering
                const tempMaxRGB = { ...maxPowerRGB };

                for (let i = 0; i < totalWindows; i++) {
                    const startSample = Math.round(i * windowIntervalSamples);

                    // Compute RMS for each frequency band
                    const lowPower = calculateRMSPower(filteredBands.low, startSample, windowSize);
                    const midPower = calculateRMSPower(filteredBands.mid, startSample, windowSize);
                    const highPower = calculateRMSPower(filteredBands.high, startSample, windowSize);

                    lowPowers.push(lowPower);
                    midPowers.push(midPower);
                    highPowers.push(highPower);

                    // Plot using Z-order curve with RGB mapping (using temp max values)
                    const index = i + zOrderOffset;
                    const { x, y } = getZOrderCoordinates(index, canvasSize);

                    if (x < canvasSize && y < canvasSize) {
                        const pixelIndex = (y * canvasSize + x) * 4;
                        // Normalize by temp max values, then scale to 0-255
                        const normalizedLow = Math.min(1, lowPower / tempMaxRGB.low);
                        const normalizedMid = Math.min(1, midPower / tempMaxRGB.mid);
                        const normalizedHigh = Math.min(1, highPower / tempMaxRGB.high);

                        imageData.data[pixelIndex] = Math.floor(normalizedLow * 255);
                        imageData.data[pixelIndex + 1] = Math.floor(normalizedMid * 255);
                        imageData.data[pixelIndex + 2] = Math.floor(normalizedHigh * 255);
                        imageData.data[pixelIndex + 3] = 255;
                    }

                    // Update canvas and progress every 100 samples
                    if (i % 100 === 0) {
                        ctx.putImageData(imageData, 0, 0);
                        const progress = (i / totalWindows) * 100;
                        progressFill.style.width = `${progress}%`;
                        progressFill.textContent = `${Math.round(progress)}%`;
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // Calculate actual max power for each band
                maxPowerRGB.low = Math.max(...lowPowers);
                maxPowerRGB.mid = Math.max(...midPowers);
                maxPowerRGB.high = Math.max(...highPowers);

                // Avoid division by zero
                if (maxPowerRGB.low === 0) maxPowerRGB.low = 1.0;
                if (maxPowerRGB.mid === 0) maxPowerRGB.mid = 1.0;
                if (maxPowerRGB.high === 0) maxPowerRGB.high = 1.0;

                // Cache for instant redraw (must be set before redrawCanvas)
                cachedRGBPowers = { low: lowPowers, mid: midPowers, high: highPowers };
                cachedPowers = null;
                cachedCanvasSize = canvasSize;
                cachedSamplesPerBeat = samplesPerBeat;
                cachedVizMode = vizMode;

                // Redraw with correct normalization
                redrawCanvas();
            }

            progressFill.style.width = '100%';
            progressFill.textContent = '100%';

            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 1000);

            isProcessing = false;
        }
    </script>
</body>
</html>
