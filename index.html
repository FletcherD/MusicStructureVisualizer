<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Structure Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 20px;
            color: #fff;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: inline-block;
            width: 180px;
            font-weight: 500;
        }

        input[type="number"],
        input[type="file"],
        select {
            padding: 8px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 14px;
        }

        input[type="number"] {
            width: 120px;
        }

        input[type="file"] {
            width: 300px;
        }

        select {
            width: 120px;
            cursor: pointer;
        }

        button {
            padding: 10px 24px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #3a7bc8;
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #4a8bd8;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .value-display {
            margin-left: 10px;
            color: #888;
            font-size: 13px;
        }

        .canvas-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        canvas {
            border: 1px solid #444;
            max-width: 100%;
            height: auto;
            image-rendering: pixelated;
        }

        .progress-container {
            margin-top: 15px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #444;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #440154, #21918c, #fde724);
            width: 0%;
            transition: width 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        .info {
            margin-top: 10px;
            color: #888;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Structure Visualizer</h1>

        <div class="controls">
            <div class="control-group">
                <label for="audioFile">Audio File:</label>
                <input type="file" id="audioFile" accept="audio/*">
            </div>

            <div class="control-group">
                <label for="bpm">BPM:</label>
                <input type="number" id="bpm" value="120" min="1" max="300" step="0.1">
            </div>

            <div class="control-group">
                <label for="samplesPerBeat">Samples per Beat:</label>
                <select id="samplesPerBeat">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="4">4</option>
                    <option value="8">8</option>
                    <option value="16">16</option>
                    <option value="32">32</option>
                    <option value="64" selected>64</option>
                    <option value="128">128</option>
                    <option value="256">256</option>
                    <option value="512">512</option>
                </select>
            </div>

            <div class="control-group">
                <label for="windowSize">Window Size (samples):</label>
                <input type="number" id="windowSize" value="2048" min="128" max="8192" step="128">
            </div>

            <div class="control-group">
                <label for="zOrderOffset">Z-Order Offset (beats):</label>
                <input type="number" id="zOrderOffset" value="0" step="0.1">
            </div>

            <div class="control-group">
                <button id="processButton" disabled>Process</button>
            </div>

            <div class="control-group info" id="calculatedInfo">
                Window interval: -- ms | Canvas size: --
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="visualizer"></canvas>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Viridis colormap (256 colors)
        const viridisMap = [
            [68, 1, 84], [68, 2, 86], [69, 4, 87], [69, 5, 89], [70, 7, 90], [70, 8, 92], [70, 10, 93], [70, 11, 94],
            [71, 13, 96], [71, 14, 97], [71, 16, 99], [71, 17, 100], [71, 19, 101], [72, 20, 103], [72, 22, 104], [72, 23, 105],
            [72, 24, 106], [72, 26, 108], [72, 27, 109], [72, 28, 110], [72, 29, 111], [72, 31, 112], [72, 32, 113], [72, 33, 115],
            [72, 35, 116], [72, 36, 117], [72, 37, 118], [72, 38, 119], [72, 40, 120], [72, 41, 121], [71, 42, 122], [71, 44, 122],
            [71, 45, 123], [71, 46, 124], [71, 47, 125], [70, 48, 126], [70, 50, 126], [70, 51, 127], [70, 52, 128], [69, 53, 129],
            [69, 55, 129], [69, 56, 130], [68, 57, 131], [68, 58, 131], [68, 59, 132], [67, 61, 132], [67, 62, 133], [66, 63, 133],
            [66, 64, 134], [66, 65, 134], [65, 66, 135], [65, 68, 135], [64, 69, 136], [64, 70, 136], [63, 71, 136], [63, 72, 137],
            [62, 73, 137], [62, 74, 137], [62, 76, 138], [61, 77, 138], [61, 78, 138], [60, 79, 138], [60, 80, 139], [59, 81, 139],
            [59, 82, 139], [58, 83, 139], [58, 84, 140], [57, 85, 140], [57, 86, 140], [56, 88, 140], [56, 89, 140], [55, 90, 140],
            [55, 91, 141], [54, 92, 141], [54, 93, 141], [53, 94, 141], [53, 95, 141], [52, 96, 141], [52, 97, 141], [51, 98, 141],
            [51, 99, 141], [50, 100, 142], [50, 101, 142], [49, 102, 142], [49, 103, 142], [49, 104, 142], [48, 105, 142], [48, 106, 142],
            [47, 107, 142], [47, 108, 142], [46, 109, 142], [46, 110, 142], [46, 111, 142], [45, 112, 142], [45, 113, 142], [44, 113, 142],
            [44, 114, 142], [44, 115, 142], [43, 116, 142], [43, 117, 142], [42, 118, 142], [42, 119, 142], [42, 120, 142], [41, 121, 142],
            [41, 122, 142], [41, 123, 142], [40, 124, 142], [40, 125, 142], [39, 126, 142], [39, 127, 142], [39, 128, 142], [38, 129, 142],
            [38, 130, 142], [38, 130, 142], [37, 131, 142], [37, 132, 142], [37, 133, 142], [36, 134, 142], [36, 135, 142], [35, 136, 142],
            [35, 137, 142], [35, 138, 141], [34, 139, 141], [34, 140, 141], [34, 141, 141], [33, 142, 141], [33, 143, 141], [33, 144, 141],
            [33, 145, 140], [32, 146, 140], [32, 146, 140], [32, 147, 140], [31, 148, 140], [31, 149, 139], [31, 150, 139], [31, 151, 139],
            [31, 152, 139], [31, 153, 138], [31, 154, 138], [30, 155, 138], [30, 156, 137], [30, 157, 137], [31, 158, 137], [31, 159, 136],
            [31, 160, 136], [31, 161, 136], [31, 161, 135], [31, 162, 135], [32, 163, 134], [32, 164, 134], [33, 165, 133], [33, 166, 133],
            [34, 167, 133], [34, 168, 132], [35, 169, 131], [36, 170, 131], [37, 171, 130], [37, 172, 130], [38, 173, 129], [39, 173, 129],
            [40, 174, 128], [41, 175, 127], [42, 176, 127], [44, 177, 126], [45, 178, 125], [46, 179, 124], [47, 180, 124], [49, 181, 123],
            [50, 182, 122], [52, 182, 121], [53, 183, 121], [55, 184, 120], [56, 185, 119], [58, 186, 118], [59, 187, 117], [61, 188, 116],
            [63, 188, 115], [64, 189, 114], [66, 190, 113], [68, 191, 112], [70, 192, 111], [72, 193, 110], [74, 193, 109], [76, 194, 108],
            [78, 195, 107], [80, 196, 106], [82, 197, 105], [84, 197, 104], [86, 198, 103], [88, 199, 101], [90, 200, 100], [92, 200, 99],
            [94, 201, 98], [96, 202, 96], [99, 203, 95], [101, 203, 94], [103, 204, 92], [105, 205, 91], [108, 205, 90], [110, 206, 88],
            [112, 207, 87], [115, 208, 86], [117, 208, 84], [119, 209, 83], [122, 209, 81], [124, 210, 80], [127, 211, 78], [129, 211, 77],
            [132, 212, 75], [134, 213, 73], [137, 213, 72], [139, 214, 70], [142, 214, 69], [144, 215, 67], [147, 215, 65], [149, 216, 64],
            [152, 216, 62], [155, 217, 60], [157, 217, 59], [160, 218, 57], [162, 218, 55], [165, 219, 54], [168, 219, 52], [170, 220, 50],
            [173, 220, 48], [176, 221, 47], [178, 221, 45], [181, 222, 43], [184, 222, 41], [186, 222, 40], [189, 223, 38], [192, 223, 37],
            [194, 223, 35], [197, 224, 33], [200, 224, 32], [202, 225, 31], [205, 225, 29], [208, 225, 28], [210, 226, 27], [213, 226, 26],
            [216, 226, 25], [218, 227, 25], [221, 227, 24], [223, 227, 24], [226, 228, 24], [229, 228, 25], [231, 228, 25], [234, 229, 26],
            [236, 229, 27], [239, 229, 28], [241, 229, 29], [244, 230, 30], [246, 230, 32], [248, 230, 33], [251, 231, 35], [253, 231, 37]
        ];

        // Z-order curve functions
        function interleave(x, y) {
            let z = 0;
            for (let i = 0; i < 16; i++) {
                z |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
            }
            return z;
        }

        function getZOrderCoordinates(index, width) {
            // Calculate x and y from linear index using Z-order curve
            let x = 0, y = 0;
            for (let i = 0; i < 16; i++) {
                x |= (index & (1 << (2 * i))) >> i;
                y |= (index & (1 << (2 * i + 1))) >> (i + 1);
            }
            return { x, y };
        }

        // Calculate RMS power of a window
        function calculateRMSPower(audioData, startSample, windowSize) {
            let sum = 0;
            const endSample = Math.min(startSample + windowSize, audioData.length);
            const actualWindowSize = endSample - startSample;

            for (let i = startSample; i < endSample; i++) {
                sum += audioData[i] * audioData[i];
            }

            return Math.sqrt(sum / actualWindowSize);
        }

        // Convert power to color using viridis colormap
        function powerToColor(power, minPower, maxPower) {
            // Handle edge case where all powers are the same
            if (minPower === maxPower) {
                const [r, g, b] = viridisMap[128]; // Use middle color
                return [r, g, b, 255];
            }

            const normalized = (power - minPower) / (maxPower - minPower);
            const index = Math.floor(Math.max(0, Math.min(1, normalized)) * 255);
            const [r, g, b] = viridisMap[index];
            return [r, g, b, 255];
        }

        // Main application state
        let audioContext;
        let audioBuffer;
        let isProcessing = false;

        // Cached computation results for quick redraw
        let cachedPowers = null;
        let cachedCanvasSize = 0;
        let cachedSamplesPerBeat = 0;

        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const calculatedInfo = document.getElementById('calculatedInfo');

        // Input elements
        const audioFileInput = document.getElementById('audioFile');
        const bpmInput = document.getElementById('bpm');
        const samplesPerBeatInput = document.getElementById('samplesPerBeat');
        const windowSizeInput = document.getElementById('windowSize');
        const zOrderOffsetInput = document.getElementById('zOrderOffset');
        const processButton = document.getElementById('processButton');

        // Initialize audio context on user interaction
        audioFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                processButton.disabled = false;
            } catch (error) {
                console.error('Error loading audio:', error);
                alert('Error loading audio file. Please try another file.');
            }
        });

        // Process button click handler
        processButton.addEventListener('click', () => {
            if (audioBuffer && !isProcessing) {
                processAudio();
            }
        });

        // Z-order offset change handler - instant redraw without recomputing
        zOrderOffsetInput.addEventListener('input', () => {
            if (cachedPowers && !isProcessing) {
                redrawCanvas();
            }
        });

        // Redraw canvas with current Z-order offset using cached data
        function redrawCanvas() {
            if (!cachedPowers) return;

            const zOrderOffsetBeats = parseFloat(zOrderOffsetInput.value);
            const zOrderOffset = Math.round(zOrderOffsetBeats * cachedSamplesPerBeat);

            // Use fixed colormap scale: 0 (silence) to 1 (max RMS power)
            const minPower = 0;
            const maxPower = 1;

            // Create new image data
            const imageData = ctx.createImageData(cachedCanvasSize, cachedCanvasSize);

            // Clear to black
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i + 3] = 255; // Set alpha to opaque
            }

            // Plot all points with new offset
            for (let i = 0; i < cachedPowers.length; i++) {
                const index = i + zOrderOffset;
                const { x, y } = getZOrderCoordinates(index, cachedCanvasSize);

                if (x < cachedCanvasSize && y < cachedCanvasSize) {
                    const color = powerToColor(cachedPowers[i], minPower, maxPower);
                    const pixelIndex = (y * cachedCanvasSize + x) * 4;
                    imageData.data[pixelIndex] = color[0];
                    imageData.data[pixelIndex + 1] = color[1];
                    imageData.data[pixelIndex + 2] = color[2];
                    imageData.data[pixelIndex + 3] = color[3];
                }
            }

            // Render to canvas
            ctx.putImageData(imageData, 0, 0);
        }

        async function processAudio() {
            if (isProcessing || !audioBuffer) return;

            isProcessing = true;
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';

            const bpm = parseFloat(bpmInput.value);
            const samplesPerBeat = parseInt(samplesPerBeatInput.value);
            const windowSize = parseInt(windowSizeInput.value);
            const zOrderOffsetBeats = parseFloat(zOrderOffsetInput.value);
            const zOrderOffset = Math.round(zOrderOffsetBeats * samplesPerBeat);

            // Get mono audio data
            const audioData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const duration = audioBuffer.duration;

            // Calculate window interval
            const beatsPerSecond = bpm / 60;
            const windowsPerSecond = beatsPerSecond * samplesPerBeat;
            const windowIntervalSeconds = 1 / windowsPerSecond;
            const windowIntervalSamples = windowIntervalSeconds * sampleRate;

            // Calculate number of windows
            const totalWindows = Math.floor(audioData.length / windowIntervalSamples);

            // Calculate canvas dimensions (smallest square power of 2 that fits all windows)
            const dimension = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(totalWindows))));
            const canvasSize = dimension;

            // Update info
            calculatedInfo.textContent = `Window interval: ${(windowIntervalSeconds * 1000).toFixed(4)} ms | Canvas size: ${canvasSize}x${canvasSize} | Total windows: ${totalWindows}`;

            // Setup canvas
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            canvas.style.width = `${Math.min(800, canvasSize)}px`;
            canvas.style.height = `${Math.min(800, canvasSize)}px`;

            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            const imageData = ctx.createImageData(canvasSize, canvasSize);
            const powers = [];

            // Use fixed colormap scale: 0 (silence) to 1 (max RMS power)
            const minPower = 0;
            const maxPower = 1;

            // Calculate power levels and draw in real-time
            for (let i = 0; i < totalWindows; i++) {
                // Precise window positioning using multiplication and rounding
                const startSample = Math.round(i * windowIntervalSamples);
                const power = calculateRMSPower(audioData, startSample, windowSize);
                powers.push(power);

                // Plot this point on canvas using Z-order curve
                const index = i + zOrderOffset;
                const { x, y } = getZOrderCoordinates(index, canvasSize);

                if (x < canvasSize && y < canvasSize) {
                    const color = powerToColor(power, minPower, maxPower);
                    const pixelIndex = (y * canvasSize + x) * 4;
                    imageData.data[pixelIndex] = color[0];
                    imageData.data[pixelIndex + 1] = color[1];
                    imageData.data[pixelIndex + 2] = color[2];
                    imageData.data[pixelIndex + 3] = color[3];
                }

                // Update canvas and progress every 100 samples
                if (i % 100 === 0) {
                    ctx.putImageData(imageData, 0, 0);
                    const progress = (i / totalWindows) * 100;
                    progressFill.style.width = `${progress}%`;
                    progressFill.textContent = `${Math.round(progress)}%`;

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // Final render
            ctx.putImageData(imageData, 0, 0);

            progressFill.style.width = '100%';
            progressFill.textContent = '100%';

            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 1000);

            // Cache the computed data for instant redraw on offset change
            cachedPowers = powers;
            cachedCanvasSize = canvasSize;
            cachedSamplesPerBeat = samplesPerBeat;

            isProcessing = false;
        }
    </script>
</body>
</html>
